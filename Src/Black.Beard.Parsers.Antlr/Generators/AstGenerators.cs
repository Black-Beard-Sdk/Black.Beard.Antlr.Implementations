using Bb.Asts;
using Bb.Parsers;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Text;

namespace Bb.Generators
{

    public class AstGenerators
    {

        public AstGenerators()
        {
            this._generators = new List<AstGenerator>();
            this._asts = new List<AstBase>();

            _provider = new CSharpCodeProvider();
            _options = new CodeGeneratorOptions() { BracingStyle = "C" };

        }


        public void Add(AstBase a)
        {
            this._asts.Add(a);
        }


        public void Add(AstGenerator g)
        {
            this._generators.Add(g);
        }

        internal void Clear()
        {
            this._asts.Clear();
        }

        public IEnumerable<string> Generate(Context ctx)
        {

            foreach (AstGenerator g in this._generators)
            {

                foreach (var item in _asts)
                    g.Generate(ctx, item);

                foreach (var file in WriteFile(ctx, g))
                    yield return file;

            }

        }

        private List<string> WriteFile(Context ctx, AstGenerator g)
        {

            var filenames = new List<string>();
            var compileUnit = g.CompileUnit;


            foreach (CodeNamespace @namespace in compileUnit.Namespaces)
            {


                foreach (CodeTypeDeclaration type in @namespace.Types)
                {

                    var toConvert = type.Members.OfType<CodeClassNested>().ToList();

                    foreach (var item in toConvert)
                    {
                        type.Members.Add(WriteMemory(item));
                        type.Members.Remove(item);
                    }

                }

            }


            if (g._root.SplitObjectOnDisk)
            {

                foreach (CodeNamespace @namespace in compileUnit.Namespaces)
                {

                    while (@namespace.Types.Count > 0)
                    {

                        // CloneCodUnit, Namspace, and move the type
                        var type = @namespace.Types[0];
                        var clonedCompileUnit = CloneCompileUnit(compileUnit);
                        var clonedNamspace = CloneNamespace(@namespace);
                        clonedCompileUnit.Namespaces.Add(clonedNamspace);
                        clonedNamspace.Types.Add(type);
                        @namespace.Types.Remove(type);

                        // Write
                        var filename = Path.Combine(ctx.OutputPath, g.Name + "." + type.Name + ".generated.cs");
                        WriteFile(g, compileUnit, filename);
                        filenames.Add(filename);

                    }

                }

            }
            else
            {
                var filename = Path.Combine(ctx.OutputPath, g.Name + ".generated.cs");
                WriteFile(g, compileUnit, filename);
                filenames.Add(filename);
            }

            return filenames;

        }

        private CodeNamespace CloneNamespace(CodeNamespace @namespace)
        {

            var result = new CodeNamespace(@namespace.Name)
            {

            };

            foreach (CodeCommentStatement item in @namespace.Comments)
                result.Comments.Add(new CodeCommentStatement(new CodeComment(item.Comment.Text, item.Comment.DocComment)));

            foreach (CodeNamespaceImport item in @namespace.Imports)
                result.Imports.Add(new CodeNamespaceImport(item.Namespace));

            return result;

        }

        private CodeCompileUnit CloneCompileUnit(CodeCompileUnit compileUnit)
        {
            return new CodeCompileUnit()
            {

            };
        }

        private void WriteFile(AstGenerator g, CodeCompileUnit compileUnit, string filename)
        {
            using (StreamWriter sw = new StreamWriter(filename, false))
            {
                IndentedTextWriter tw = new IndentedTextWriter(sw, "    ");
                tw.Write("#nullable disable");
                tw.WriteLine();
                tw.Write("// Generated by " + g.Name + " : " + DateTime.Now.ToString("D"));
                tw.WriteLine();
                _provider.GenerateCodeFromCompileUnit(compileUnit, tw, _options);
                tw.Close();
            }
        }

        private CodeSnippetTypeMember WriteMemory(CodeClassNested member)
        {
            using (var memory = new MemoryStream())
            using (StreamWriter sw = new StreamWriter(memory))
            {

                IndentedTextWriter tw = new IndentedTextWriter(sw, "    ");

                foreach (CodeTypeDeclaration type in member.Items)
                    _provider.GenerateCodeFromType(type, tw, _options);

                tw.Close();

                var txt = System.Text.UTF8Encoding.UTF8.GetString(memory.ToArray()).Split("\n");

                StringBuilder sb = new StringBuilder();
                foreach (var c in txt)
                {
                    sb.Append("        ");
                    sb.AppendLine(c.Trim('\r'));
                }

                return new CodeSnippetTypeMember(sb.ToString());

            }

        }

        private readonly List<AstGenerator> _generators;
        private readonly List<AstBase> _asts;
        private readonly CSharpCodeProvider _provider;
        private readonly CodeGeneratorOptions _options;
    }



}

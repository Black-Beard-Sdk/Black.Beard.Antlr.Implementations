using Bb.Asts;
using Bb.Parsers;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Text;

namespace Bb.Generators
{

    public class AstGenerators
    {

        public AstGenerators()
        {
            this._generators = new List<AstGenerator>();
            this._asts = new List<AstBase>();

            _provider = new CSharpCodeProvider();
            _options = new CodeGeneratorOptions() { BracingStyle = "C" };

        }


        public void Add(AstBase a)
        {
            this._asts.Add(a);
        }


        public void Add(AstGenerator g)
        {
            this._generators.Add(g);
        }

        internal void Clear()
        {
            this._asts.Clear();
        }

        public void Generate(Context ctx, HashSet<string> generateds)
        {

            foreach (AstGenerator g in this._generators)
            {

                foreach (var item in _asts)
                    g.Generate(ctx, item);

                WriteFile(ctx, g, generateds);
                  
            }

        }

        private void WriteFile(Context ctx, AstGenerator g, HashSet<string> generateds)
        {

            var compileUnit = g.CompileUnit;

            foreach (CodeNamespace @namespace in compileUnit.Namespaces)
                foreach (CodeTypeDeclaration type in @namespace.Types)
                {
                    var toConvert = type.Members.OfType<CodeClassNested>().ToList();
                    foreach (var item in toConvert)
                    {
                        type.Members.Add(WriteMemory(item));
                        type.Members.Remove(item);
                    }
                }


            if (g._root.SplitObjectOnDisk)
            {

                foreach (CodeNamespace @namespace in compileUnit.Namespaces)
                {

                    while (@namespace.Types.Count > 0)
                    {

                        // CloneCodUnit, Namspace, and move the type
                        var type = @namespace.Types[0];
                        var clonedCompileUnit = CloneCompileUnit(compileUnit);
                        var clonedNamspace = CloneNamespace(@namespace);
                        clonedCompileUnit.Namespaces.Add(clonedNamspace);
                        clonedNamspace.Types.Add(type);
                        @namespace.Types.Remove(type);

                        // Write
                        var filename = Path.Combine(ctx.OutputPath, g.Name + "." + type.Name + ".generated.cs");
                        WriteFile(g, compileUnit, filename, generateds);

                    }

                }

            }
            else
            {
                var filename = Path.Combine(ctx.OutputPath, g.Name + ".generated.cs");
                WriteFile(g, compileUnit, filename, generateds);                
            }

        }

        private CodeNamespace CloneNamespace(CodeNamespace @namespace)
        {

            var result = new CodeNamespace(@namespace.Name)
            {

            };

            foreach (CodeCommentStatement item in @namespace.Comments)
                result.Comments.Add(new CodeCommentStatement(new CodeComment(item.Comment.Text, item.Comment.DocComment)));

            foreach (CodeNamespaceImport item in @namespace.Imports)
                result.Imports.Add(new CodeNamespaceImport(item.Namespace));

            return result;

        }

        private CodeCompileUnit CloneCompileUnit(CodeCompileUnit compileUnit)
        {
            return new CodeCompileUnit()
            {

            };
        }

        private void WriteFile(AstGenerator g, CodeCompileUnit compileUnit, string filename, HashSet<string> generateds)
        {

            if (generateds.Contains(filename))
            {
                var f = new FileInfo(filename);
                int i = 1;

                string name = Path.GetFileNameWithoutExtension(f.Name);
                string extension = f.Extension;

                var f2 = Path.Combine(f.Directory.FullName, name + (i++).ToString() + extension);
                while (File.Exists(f2))
                {
                    f2 = Path.Combine(f.Directory.FullName, name + (i++).ToString() + extension);
                }

                filename = f2;

            }

            using (StreamWriter sw = new StreamWriter(filename, false))
            {
                IndentedTextWriter tw = new IndentedTextWriter(sw, "    ");
                tw.Write("#nullable disable");
                tw.WriteLine();
                tw.Write("// Generated by " + g._root.GetType().Name + ".cs (" + DateTime.Now.ToString("D") + ")");
                tw.WriteLine();
                _provider.GenerateCodeFromCompileUnit(compileUnit, tw, _options);
                tw.Close();

                generateds.Add(filename);

            }            

        }

        private CodeSnippetTypeMember WriteMemory(CodeClassNested member)
        {
            using (var memory = new MemoryStream())
            using (StreamWriter sw = new StreamWriter(memory))
            {

                IndentedTextWriter tw = new IndentedTextWriter(sw, "    ");

                foreach (CodeTypeDeclaration type in member.Items)
                    _provider.GenerateCodeFromType(type, tw, _options);

                tw.Close();

                var txt = System.Text.UTF8Encoding.UTF8.GetString(memory.ToArray()).Split("\n");

                StringBuilder sb = new StringBuilder();
                foreach (var c in txt)
                {
                    sb.Append("        ");
                    sb.AppendLine(c.Trim('\r'));
                }

                return new CodeSnippetTypeMember(sb.ToString());

            }

        }

        private readonly List<AstGenerator> _generators;
        private readonly List<AstBase> _asts;
        private readonly CSharpCodeProvider _provider;
        private readonly CodeGeneratorOptions _options;
   
    }



}
